import os, subprocess, re
import threading
import walb_worker

g_testNum = 0
g_errNum = 0

def expectEqual(lhs, rhs):
    global g_testNum
    global g_errNum
    g_testNum += 1
    if lhs != rhs:
        print 'ERR'
        print ' lhs', lhs
        print ' rhs', rhs
        g_errNum += 1

CONF="""
general:
  addr: localhost
  port: 10200
  walbc_path: binsrc/walbc
  max_task: 2
  max_replication_task: 5
  kick_interval: 1
apply:
  keep_period: 10
  interval: 100
merge:
  interval: 10
  max_nr: 10
  max_size: 1M
  threshold_nr: 5
repl_servers:
  repl0:
    addr: localhost
    port: 10201
    interval: 20
    compress: snappy:0:1
    max_merge_size: 5K
    bulk_size: 4K
"""
execfile('stest/config0.py')

def makeDiff():
    for i in xrange(4):
        !dd if=/dev/urandom of=/dev/walb/0 count=1k bs=512
    time.sleep(2)

def rewriteBase():
    base = walbc.get_base(a0, VOL)
    if base.E is None:
        print 'change', base,
        latest = walbc.get_latest_clean_snapshot(a0, VOL)
        if base.E != latest:
            base.E = Snapshot(latest, latest)
            print 'to', base
    s = '"' + str(base) + '"'
    !binsrc/walbc -a localhost -p 10200 dbg-set-base vol0 {s}

def parseLog(s):
    S_SELECT = 0
    S_START = 1
    S_END = 2

    mode = S_SELECT
    ls = []

    for line in s.split('\n'):
        p = RE_LOG.match(line)
        if p:
            time = p.group(1)
            level = p.group(2)
            m = p.group(3)
            r = parseTask(m)
            if r is None:
                continue
            (a, t) = r
            if mode == S_SELECT:
                if a.find('select') >=0:
                    action = a
                    mode = S_START
            elif mode == S_START:
                if a == 'startTask':
                    mode = S_END
            elif mode == S_END:
                ls.append((action, t))
                mode = S_SELECT
    return ls

def runWorker(cfg, step, lifetime=5, lastApply=0):
    args = [
        '/usr/bin/python', 'python/walb_worker.py', '-f', '-',
        '-lifetime', str(lifetime), '-d', '-step', str(step),
        '-lastapply', str(lastApply),
    ]
    p = subprocess.Popen(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=sys.stderr, close_fds=True)
    ifs = p.stdin
    ifs.write(str(cfg))
    ifs.close()
    ofs = p.stdout
    s = ofs.read().strip()
    ret = p.wait()
    if ret != 0:
        raise Exception('runWorker err', args, ret)
    print>>sys.stderr, s
    return parseLog(s)

RE_LOG = re.compile('(\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d\.\d{6}) ([A-Z]+) (.*)')

def parseTask(s):
    pos = s.find(':')
    if pos > 0:
        action = s[0:pos]
        task = s[pos+1:]
        return (action, task)
    else:
        return None

def testStep1(cfg):
    # do nothing if no diff
    ls = runWorker(cfg, 1)
    expectEqual(ls, [])

    # make applying state, then ApplyTask1 will be selected
    makeDiff()
    rewriteBase()
    ls = runWorker(cfg, 1)
    expectEqual(len(ls), 1)
    expectEqual(ls[0][0], 'selectApplyTask1')

def testStep2(cfg):
    makeDiff()
    # do nothing if in apply.interval
    ls = runWorker(cfg, 2, lastApply=20)
    expectEqual(ls, [])
    # ApplyTask2 is selected immediately
    ls = runWorker(cfg, 2)
    expectEqual(len(ls), 1)
    expectEqual(ls[0][0], 'selectApplyTask2')

def main():
    cfg = walb_worker.Config()
    cfg.setStr(CONF)
    testStep1(cfg)
    testStep2(cfg)
    print "test {} / {}".format(g_errNum, g_testNum)

if __name__ == "__main__":
    main()
