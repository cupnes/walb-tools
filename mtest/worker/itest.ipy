import os, subprocess
import threading
import walb_worker

CONF="""
general:
  addr: localhost
  port: 10200
  walbc_path: binsrc/walbc
  max_task: 2
  max_replication_task: 5
  kick_interval: 3
apply:
  keep_period: 30
  interval: 10
merge:
  interval: 10
  max_nr: 10
  max_size: 1M
  threshold_nr: 5
repl_servers:
  repl0:
    addr: localhost
    port: 10201
    interval: 20
    compress: snappy:0:1
    max_merge_size: 5K
    bulk_size: 4K
"""
execfile('stest/config0.py')

def make_diff():
    !dd if=/dev/urandom of=/dev/walb/0 count=1k bs=512
    !dd if=/dev/urandom of=/dev/walb/0 count=1k bs=512

def rewrite_base():
    base = str(walbc.get_base(a0, VOL))
    latest = walbc.get_latest_clean_snapshot(a0, VOL)
    if base.find('-->') >= 0:
        print 'not clean base', base
        os._exit(1)
    sp = base.split('>')
    base2 = '"' + sp[0] + '-->|' + str(latest) + '|>' + sp[1] + '"'
    print 'change', base, 'to', base2
    !binsrc/walbc -a localhost -p 10200 dbg-set-base vol0 {base2}

def runWorker(cfg, step):
    lifetime=5
    args = [
        '/usr/bin/python', 'python/walb_worker.py', '-f', '-',
        '-lifetime', str(lifetime), '-d', '-step', str(step)
    ]
    p = subprocess.Popen(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=sys.stderr, close_fds=True)
    ifs = p.stdin
    ifs.write(str(cfg))
    ifs.close()
    ofs = p.stdout
    s = ofs.read().strip()
    ret = p.wait()
    if ret != 0:
        raise Exception('runWorker err', args, ret)
    return s

# test step 1
def testStep1(cfg):
    make_diff()
    time.sleep(2)
    rewrite_base()
    ret = runWorker(cfg, 1)
    if ret.find('selectApplyTask1') >= 0:
        print 'ok step1'
        print ret
    else:
        print 'err'
        print ret

def main():
    cfg = walb_worker.Config()
    cfg.setStr(CONF)
    testStep1(cfg)

if __name__ == "__main__":
    main()
